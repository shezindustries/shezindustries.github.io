<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sheztris - Modern Tetris</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

  body {
    margin: 0; 
    background: #121212;
    font-family: 'Orbitron', monospace;
    color: #eee;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    height: 100vh;
    user-select: none;
  }
  #container {
    margin-top: 20px;
    display: flex;
    gap: 30px;
    background: #1f1f1f;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 0 20px #00ffccaa;
  }
  #game {
    position: relative;
  }
  #title {
    font-size: 48px;
    color: #00ffc8;
    text-shadow: 0 0 15px #00ffc8aa, 0 0 30px #00ffc8bb;
    margin-bottom: 15px;
    letter-spacing: 6px;
    user-select: none;
    text-align: center;
    font-weight: 900;
  }
  canvas {
    background: #0e0e0e;
    border-radius: 10px;
    box-shadow: inset 0 0 20px #00ffccbb;
    image-rendering: pixelated;
    display: block;
  }
  #info {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    color: #00ffc8cc;
    font-weight: 600;
    font-size: 18px;
  }
  #scoreboard {
    margin-bottom: 20px;
  }
  .label {
    font-size: 14px;
    opacity: 0.7;
  }
  .value {
    font-size: 22px;
    margin-bottom: 15px;
    letter-spacing: 1.5px;
  }
  #nextPieces {
    background: #121212;
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 0 20px #00ffcc99;
    user-select: none;
  }
  #nextPieces h2 {
    margin: 0 0 12px 0;
    font-size: 22px;
    color: #00ffc8dd;
    text-align: center;
  }
  .next-canvas {
    background: #0e0e0e;
    border-radius: 8px;
    margin-bottom: 12px;
    box-shadow: inset 0 0 10px #00ffcc88;
  }
  #controls {
    margin-top: 20px;
    background: #121212ee;
    padding: 15px;
    border-radius: 12px;
    font-size: 14px;
    color: #00ffc8cc;
    text-align: center;
    user-select: none;
    max-width: 250px;
  }

  /* Block styling for modern look */
  .block {
    box-shadow:
      inset 0 0 10px #00ffcc,
      0 0 8px #00ffccaa;
  }

</style>
</head>
<body>
  <div id="container">
    <div id="game">
      <div id="title">SHEZTRIS</div>
      <canvas id="tetris" width="240" height="400"></canvas>
      <div id="controls">
        Controls:<br />
        ← / →: Move &nbsp;&nbsp; ↑: Rotate &nbsp;&nbsp; ↓: Soft Drop<br />
        Space: Hard Drop &nbsp;&nbsp; P: Pause
      </div>
    </div>
    <div id="info">
      <div id="scoreboard">
        <div><span class="label">Score</span><br/><span id="score" class="value">0</span></div>
        <div><span class="label">Level</span><br/><span id="level" class="value">1</span></div>
        <div><span class="label">Lines</span><br/><span id="lines" class="value">0</span></div>
      </div>
      <div id="nextPieces">
        <h2>Next</h2>
        <canvas id="next1" class="next-canvas" width="80" height="80"></canvas>
        <canvas id="next2" class="next-canvas" width="80" height="80"></canvas>
        <canvas id="next3" class="next-canvas" width="80" height="80"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  ctx.scale(20, 20);

  const nextCanvases = [
    document.getElementById('next1').getContext('2d'),
    document.getElementById('next2').getContext('2d'),
    document.getElementById('next3').getContext('2d')
  ];
  nextCanvases.forEach(c => c.scale(20, 20));

  const colors = [
    null,
    '#ff0055',
    '#00d4ff',
    '#00ff55',
    '#cc00ff',
    '#ff8c00',
    '#ffff00',
    '#0055ff',
  ];

  const pieces = 'TJLOSZI';

  function createPiece(type) {
    switch(type) {
      case 'T': return [
        [0,1,0],
        [1,1,1],
        [0,0,0],
      ];
      case 'J': return [
        [1,0,0],
        [1,1,1],
        [0,0,0],
      ];
      case 'L': return [
        [0,0,1],
        [1,1,1],
        [0,0,0],
      ];
      case 'O': return [
        [1,1],
        [1,1],
      ];
      case 'S': return [
        [0,1,1],
        [1,1,0],
        [0,0,0],
      ];
      case 'Z': return [
        [1,1,0],
        [0,1,1],
        [0,0,0],
      ];
      case 'I': return [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0],
      ];
    }
  }

  function createMatrix(w,h) {
    const matrix = [];
    while(h--) matrix.push(new Array(w).fill(0));
    return matrix;
  }

  function drawBlock(ctx, x, y, colorIndex) {
    ctx.fillStyle = colors[colorIndex];
    ctx.shadowColor = colors[colorIndex];
    ctx.shadowBlur = 8;
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 0.08;
    ctx.fillRect(x, y, 1, 1);
    ctx.strokeRect(x+0.05, y+0.05, 0.9, 0.9);
  }

  function drawMatrix(ctx, matrix, offset) {
    matrix.forEach((row, y) => {
      row.forEach((val, x) => {
        if(val !== 0) drawBlock(ctx, x + offset.x, y + offset.y, val);
      });
    });
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((val, x) => {
        if(val !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = val;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for(let y=0; y < m.length; y++) {
      for(let x=0; x < m[y].length; x++) {
        if(m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function rotate(matrix, dir) {
    for(let y=0; y < matrix.length; y++) {
      for(let x=0; x < y; x++) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerReset() {
    player.matrix = nextQueue.shift();
    nextQueue.push(createPiece(pieces[Math.floor(Math.random() * pieces.length)]));
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
    if(collide(arena, player)) {
      arena.forEach(row => row.fill(0));
      score = 0;
      level = 1;
      lines = 0;
      dropInterval = 800;
      nextQueue = [];
      for(let i=0; i<3; i++) {
        nextQueue.push(createPiece(pieces[Math.floor(Math.random() * pieces.length)]));
      }
      updateScore();
    }
  }

  function arenaSweep() {
    let rowCount = 0;
    outer: for(let y=arena.length -1; y >= 0; --y) {
      if(arena[y].every(cell => cell !== 0)) {
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        rowCount++;
        y++;
      }
    }
    if(rowCount > 0) {
      lines += rowCount;
      score += rowCount * 100 * level;
      if(lines >= level * 10) {
        level++;
        dropInterval *= 0.85;
      }
      updateScore();
    }
  }

  function updateScore() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
  }

  let dropCounter = 0;
  let dropInterval = 800;
  let lastTime = 0;
  let isPaused = false;

  const arena = createMatrix(12, 20);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
  };

  let score = 0;
  let level = 1;
  let lines = 0;

  let nextQueue = [];
  for(let i=0; i<3; i++) {
    nextQueue.push(createPiece(pieces[Math.floor(Math.random() * pieces.length)]));
  }

  function draw() {
    ctx.fillStyle = '#0e0e0e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMatrix(ctx, arena, {x:0, y:0});
    drawMatrix(ctx, player.matrix, player.pos);
  }

  function drawNext() {
    nextCanvases.forEach((nxCtx, idx) => {
      nxCtx.clearRect(0, 0, nxCtx.canvas.width, nxCtx.canvas.height);
      const piece = nextQueue[idx];
      if(piece) drawMatrix(nxCtx, piece, {x:1, y:1});
    });
  }

  function update(time=0) {
    if(isPaused) {
      requestAnimationFrame(update);
      return;
    }
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if(dropCounter > dropInterval) {
      player.pos.y++;
      if(collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
      }
      dropCounter = 0;
    }

    draw();
    drawNext();
    requestAnimationFrame(update);
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if(collide(arena, player)) player.pos.x -= dir;
  }

  function playerRotate(dir) {
    rotate(player.matrix, dir);
    if(collide(arena, player)) {
      rotate(player.matrix, -dir);
    }
  }

  function hardDrop() {
    while(!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--;
    merge(arena, player);
    playerReset();
    arenaSweep();
  }

  document.addEventListener('keydown', event => {
    if(event.repeat) return;
    if(event.key === 'ArrowLeft') playerMove(-1);
    else if(event.key === 'ArrowRight') playerMove(1);
    else if(event.key === 'ArrowDown') {
      player.pos.y++;
      if(collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
      }
      dropCounter = 0;
    }
    else if(event.key === 'ArrowUp') playerRotate(1);
    else if(event.key === ' ') hardDrop();
    else if(event.key.toLowerCase() === 'p') isPaused = !isPaused;
  });

  playerReset();
  updateScore();
  update();
})();
</script>
</body>
</html>
